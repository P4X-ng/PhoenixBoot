#!/usr/bin/env python3
"""
PhoenixGuard Kernel Module Signing Tool (pgmodsign)
Part of the edk2-bootkit-defense project

Signs kernel modules using PhoenixGuard certificates for SecureBoot compliance.
Leverages the Linux kernel's scripts/sign-file utility.
"""

import os
import sys
import json
import logging
import subprocess
import hashlib
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Any, Optional, Tuple
import traceback

# Set up logging with extensive detail
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - [%(filename)s:%(lineno)d] - %(message)s',
    handlers=[
        logging.FileHandler('/var/log/phoenixguard/module_signing.log'),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)

class PhoenixGuardModuleSigner:
    def __init__(self, cert_path: str = None, key_path: str = None):
        self.cert_path = cert_path or "/home/punk/Projects/edk2-bootkit-defense/PhoenixGuard/out/keys/MokNew.crt"
        self.key_path = key_path or "/home/punk/Projects/edk2-bootkit-defense/PhoenixGuard/out/keys/MokNew.key"
        self.sign_file_paths = [
            "/usr/src/linux-headers-$(uname -r)/scripts/sign-file",
            "/lib/modules/$(uname -r)/build/scripts/sign-file",
            "/usr/src/kernels/$(uname -r)/scripts/sign-file"
        ]
        self.signing_cache = {}
        self.signing_log = []
        self.cert_inventory = {} # Initialize cert_inventory
        
        # Ensure log directory exists
        os.makedirs("/var/log/phoenixguard", exist_ok=True)
        
        # Load certificate inventory
        self.load_certificate()
        
    def load_certificate(self):
        """Load the most recent certificate inventory"""
        self.cert_file = Path(self.cert_path)
        self.key_file = Path(self.key_path)
           
    
    def run_command(self, cmd: str, check: bool = True, shell: bool = True) -> subprocess.CompletedProcess:
        """Run shell command with extensive logging"""
        logger.info(f"Executing command: {cmd}")
        
        try:
            result = subprocess.run(
                cmd, 
                shell=shell, 
                capture_output=True, 
                text=True, 
                check=check,
                timeout=60
            )
            
            if result.stdout:
                logger.debug(f"STDOUT: {result.stdout}")
            if result.stderr:
                logger.debug(f"STDERR: {result.stderr}")
            
            logger.info(f"Command completed with return code: {result.returncode}")
            return result
            
        except subprocess.CalledProcessError as e:
            logger.error(f"Command failed with exit code {e.returncode}")
            logger.error(f"STDERR: {e.stderr}")
            raise
        except subprocess.TimeoutExpired as e:
            logger.error(f"Command timed out after 60 seconds")
            raise
    
    def find_sign_file_utility(self) -> Optional[str]:
        """Locate the kernel's sign-file utility"""
        logger.info("Searching for sign-file utility")
        
        # Try common locations
        for path_template in self.sign_file_paths:
            # Expand shell variables
            expanded_path = os.path.expandvars(path_template)
            
            try:
                # Use shell expansion for $(uname -r)
                result = self.run_command(f"echo {expanded_path}", check=False)
                actual_path = result.stdout.strip()
                
                if Path(actual_path).exists():
                    logger.info(f"Found sign-file utility: {actual_path}")
                    return actual_path
                    
            except Exception:
                continue
        
        # Try locating via find
        try:
            result = self.run_command("find /usr/src /lib/modules -name 'sign-file' 2>/dev/null | head -1", check=False)
            if result.stdout.strip():
                sign_file_path = result.stdout.strip()
                logger.info(f"Found sign-file utility via find: {sign_file_path}")
                return sign_file_path
        except Exception:
            pass
        
        logger.error("Could not locate sign-file utility")
        return None
    
    def get_signing_certificate(self):
        """Get the preferred signing certificate and private key"""
        return self.cert_path, self.key_path
    
    def calculate_module_hash(self, module_path: str) -> str:
        """Calculate SHA256 hash of the module file"""
        hash_sha256 = hashlib.sha256()
        
        with open(module_path, "rb") as f:
            for chunk in iter(lambda: f.read(4096), b""):
                hash_sha256.update(chunk)
        
        return hash_sha256.hexdigest()
    
    def is_module_signed(self, module_path: str) -> bool:
        """Check if a kernel module is already signed"""
        try:
            # Use modinfo to check for signature
            result = self.run_command(f"modinfo '{module_path}' | grep -q 'sig_id'", check=False)
            is_signed = result.returncode == 0
            
            logger.info(f"Module {Path(module_path).name} signature status: {'SIGNED' if is_signed else 'UNSIGNED'}")
            return is_signed
            
        except Exception as e:
            logger.warning(f"Could not determine signature status for {module_path}: {e}")
            return False
    
    def sign_kernel_module(self, module_path: str, cert_preference: str = "latest", 
                          hash_algo: str = "sha256", force: bool = False) -> Dict[str, Any]:
        """Sign a kernel module with PhoenixGuard certificate"""
        
        module_path = Path(module_path).resolve()
        
        if not module_path.exists():
            raise FileNotFoundError(f"Module file not found: {module_path}")
        
        if not module_path.suffix == '.ko':
            raise ValueError(f"File does not appear to be a kernel module: {module_path}")
        
        logger.info(f"Starting module signing process for: {module_path}")
        
        # Check if already signed
        if not force and self.is_module_signed(str(module_path)):
            logger.warning(f"Module is already signed. Use --force to re-sign.")
            return {
                'status': 'skipped',
                'reason': 'already_signed',
                'module_path': str(module_path),
                'timestamp': datetime.now().isoformat()
            }
        
        # Find sign-file utility
        sign_file = self.find_sign_file_utility()
        if not sign_file:
            raise RuntimeError("Could not locate sign-file utility")
        
        # Get signing certificate and key
        cert_path, key_path = self.get_signing_certificate()
        if not cert_path or not key_path:
            raise RuntimeError("Could not locate suitable signing certificate")
        
        # Calculate pre-signing hash
        pre_hash = self.calculate_module_hash(str(module_path))
        
        # Create backup
        backup_path = module_path.with_suffix('.ko.unsigned')
        if not backup_path.exists():
            import shutil
            shutil.copy2(module_path, backup_path)
            logger.info(f"Created backup: {backup_path}")
        
        # Sign the module
        sign_cmd = f"{sign_file} {hash_algo} '{key_path}' '{cert_path}' '{module_path}'"
        
        try:
            logger.info("Executing signing command...")
            result = self.run_command(sign_cmd)
            
            # Calculate post-signing hash
            post_hash = self.calculate_module_hash(str(module_path))
            
            # Verify signing was successful
            if self.is_module_signed(str(module_path)):
                signing_result = {
                    'status': 'success',
                    'module_path': str(module_path),
                    'certificate_used': cert_path,
                    'private_key_used': key_path,
                    'hash_algorithm': hash_algo,
                    'pre_signing_hash': pre_hash,
                    'post_signing_hash': post_hash,
                    'backup_created': str(backup_path),
                    'timestamp': datetime.now().isoformat(),
                    'sign_file_utility': sign_file,
                    'command_executed': sign_cmd
                }
                
                logger.info("✅ Module signing completed successfully")
                
            else:
                signing_result = {
                    'status': 'failed',
                    'reason': 'signature_not_detected',
                    'module_path': str(module_path),
                    'timestamp': datetime.now().isoformat()
                }
                
                logger.error("❌ Module signing failed - signature not detected")
            
        except Exception as e:
            signing_result = {
                'status': 'error',
                'error': str(e),
                'module_path': str(module_path),
                'timestamp': datetime.now().isoformat()
            }
            
            logger.error(f"❌ Module signing failed with error: {e}")
        
        # Log the signing event
        self.signing_log.append(signing_result)
        
        return signing_result
    
    def sign_multiple_modules(self, module_paths: List[str], **kwargs) -> List[Dict[str, Any]]:
        """Sign multiple kernel modules"""
        results = []
        
        logger.info(f"Starting batch signing of {len(module_paths)} modules")
        
        for module_path in module_paths:
            try:
                result = self.sign_kernel_module(module_path, **kwargs)
                results.append(result)
            except Exception as e:
                error_result = {
                    'status': 'error',
                    'error': str(e),
                    'module_path': str(module_path),
                    'timestamp': datetime.now().isoformat()
                }
                results.append(error_result)
                logger.error(f"Failed to sign {module_path}: {e}")
        
        successful = len([r for r in results if r['status'] == 'success'])
        logger.info(f"Batch signing completed: {successful}/{len(module_paths)} modules signed successfully")
        
        return results
    
    def save_signing_log(self, output_file: str = None) -> str:
        """Save signing log to JSON file"""
        if not output_file:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            output_file = f"/var/log/phoenixguard/module_signing_log_{timestamp}.json"
        
        log_data = {
            'signing_session': {
                'timestamp': datetime.now().isoformat(),
                'total_operations': len(self.signing_log),
                'successful_signings': len([r for r in self.signing_log if r['status'] == 'success']),
                'failed_signings': len([r for r in self.signing_log if r['status'] == 'failed']),
                'errors': len([r for r in self.signing_log if r['status'] == 'error'])
            },
            'signing_events': self.signing_log,
            'certificate_inventory_used': self.cert_inventory.get('scan_info', {}),
            'environment': {
                'hostname': os.uname().nodename,
                'kernel_version': os.uname().release,
                'architecture': os.uname().machine
            }
        }
        
        with open(output_file, 'w') as f:
            json.dump(log_data, f, indent=2, sort_keys=True)
        
        logger.info(f"Signing log saved to: {output_file}")
        return output_file

def main():
    """Main entry point for pgmodsign CLI"""
    import argparse
    
    parser = argparse.ArgumentParser(
        description='PhoenixGuard Kernel Module Signing Tool',
        epilog='Examples:\n'
               '  pgmodsign module.ko                    # Sign single module\n'
               '  pgmodsign *.ko                         # Sign all .ko files\n'
               '  pgmodsign --force module.ko            # Re-sign already signed module\n'
               '  pgmodsign --cert-index 2 module.ko     # Use specific certificate',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    parser.add_argument('modules', nargs='+', help='Kernel module files to sign (.ko)')
    parser.add_argument('--cert-path', help='Certificate directory path')
    parser.add_argument('--key-path', help='Certificate directory path')
    parser.add_argument('--hash-algo', default='sha256', 
                       choices=['sha1', 'sha224', 'sha256', 'sha384', 'sha512'],
                       help='Hash algorithm for signing (default: sha256)')
    parser.add_argument('--force', '-f', action='store_true', 
                       help='Force re-signing of already signed modules')
    parser.add_argument('--verbose', '-v', action='store_true', help='Verbose logging')
    parser.add_argument('--output', '-o', help='Output log file path')
    
    args = parser.parse_args()
    
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
    
    try:
        # Initialize signer
        signer = PhoenixGuardModuleSigner(args.cert_path, args.key_path)
        
        # Expand glob patterns
        module_files = []
        for pattern in args.modules:
            expanded = list(Path('.').glob(pattern))
            if expanded:
                module_files.extend([str(p) for p in expanded if p.suffix == '.ko'])
            else:
                module_files.append(pattern)
        
        if not module_files:
            logger.error("No kernel module files specified")
            return 1
        
        logger.info(f"Found {len(module_files)} module(s) to sign")
        
        # Sign modules
        if len(module_files) == 1:
            result = signer.sign_kernel_module(
                module_files[0],
                cert_preference=args.cert_index,
                hash_algo=args.hash_algo,
                force=args.force
            )
            results = [result]
        else:
            results = signer.sign_multiple_modules(
                module_files,
                cert_preference=args.cert_index,
                hash_algo=args.hash_algo,
                force=args.force
            )
        
        # Save signing log
        log_file = signer.save_signing_log(args.output)
        
        # Print summary
        successful = len([r for r in results if r['status'] == 'success'])
        skipped = len([r for r in results if r['status'] == 'skipped'])
        failed = len([r for r in results if r['status'] in ['failed', 'error']])
        
        print(f"\n📊 Signing Summary:")
        print(f"  ✅ Successfully signed: {successful}")
        print(f"  ⏭️  Skipped (already signed): {skipped}")
        print(f"  ❌ Failed: {failed}")
        print(f"  📄 Log file: {log_file}")
        
        if failed > 0:
            print(f"\n❌ Some modules failed to sign:")
            for result in results:
                if result['status'] in ['failed', 'error']:
                    print(f"  • {Path(result['module_path']).name}: {result.get('error', result.get('reason', 'Unknown error'))}")
        
        return 0 if failed == 0 else 1
        
    except Exception as e:
        logger.error(f"Module signing failed: {e}")
        logger.error(traceback.format_exc())
        return 1

if __name__ == '__main__':
    sys.exit(main())
